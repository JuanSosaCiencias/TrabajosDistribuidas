{\large{
    \begin{enumerate}
        \item \textbf{Inicialización de procesos:}
        \begin{itemize}
            \item La función \texttt{Main.run(10, 1)} inicializa:
            \begin{itemize}
                \item Una red de 10 nodos, representados como procesos de Elixir.
                \item La blockchain, que comienza con un bloque génesis común a todos los nodos.
            \end{itemize}
        \end{itemize}
        
        \item \textbf{Construcción de la red:}
        \begin{itemize}
            \item Los procesos se conectan entre sí utilizando el modelo Watts y Strogatz, garantizando un coeficiente de agrupación mayor a 0.4.
            \item Cada nodo guarda una copia inicial de la blockchain, comenzando con el bloque génesis.
        \end{itemize}
        
        \item \textbf{Propuesta de un nuevo bloque:}
        \begin{itemize}
            \item Un nodo selecciona o recibe la tarea de proponer un bloque nuevo.
            \item El nodo genera el bloque con la siguiente información:
            \begin{itemize}
                \item \textbf{data:} El contenido del bloque, por ahora un string.
                \item \textbf{timestamp:} La marca de tiempo de la creación del bloque.
                \item \textbf{previous\_hash:} El hash del bloque anterior en la blockchain.
                \item \textbf{hash:} El hash del bloque actual.
            \end{itemize}
            \item El bloque es transmitido a todos los nodos de la red, esto es, se envia el mensaje a los vecinos, valida el bloque y si es correcto lo propaga a sus vecinos. El mensaje se transmite incluyendo el identificador del nodo que lo propuso para que pueda recopilar los votos.
        \end{itemize}
        
        \item \textbf{Proceso de votación:}
        \begin{itemize}
            \item Cada nodo recibe el bloque propuesto y realiza las siguientes verificaciones:
            \begin{itemize}
                \item ¿El data del bloque es un string?
                \item ¿El hash del bloque anterior coincide con su propia blockchain?
                \item ¿El hash del bloque actual es válido?
                \item ¿El timestamp del bloque es posterior al último bloque de la blockchain?
            \end{itemize}
            \item Con base en las verificaciones, el nodo responde con un voto:
            \begin{itemize}
                \item \texttt{ACEPTAR} si el bloque es válido.
                \item \texttt{RECHAZAR} si el bloque es inválido.
            \end{itemize}
        \end{itemize}
        
        \item \textbf{Decisión de consenso:}
        \begin{itemize}
            \item El nodo proponente recolecta los votos de todos los nodos; para esto, los nodos checan el identificador del nodo que propuso el bloque, si es vecino inmediato se envía el voto, si no se reenvía a los vecinos, estos recopilan los votos y los envían al nodo proponente, vamos a usar TTL para eviar que los mensajes se propaguen indefinidamente.
            \item Si más del 50\% de los votos son \texttt{ACEPTAR}, el bloque es considerado válido:
            \begin{itemize}
                \item El bloque se agrega a la blockchain del nodo proponente.
                \item El bloque es propagado a todos los nodos para que lo agreguen a sus respectivas blockchains, se usa un mensaje diferente al de proponer.
            \end{itemize}
            \item Si no se alcanza el consenso, el bloque es descartado.
        \end{itemize}
        
        \item \textbf{Interacción desde el evaluador:}
        \begin{itemize}
            \item El evaluador puede utilizar la terminal interactiva de Elixir (\texttt{iex}) para:
            \begin{itemize}
                \item Insertar bloques nuevos.
                \item Verificar que las blockchains de todos los nodos son consistentes y reflejan los mismos bloques.-
            \end{itemize}
        \end{itemize}
    \end{enumerate}
}}