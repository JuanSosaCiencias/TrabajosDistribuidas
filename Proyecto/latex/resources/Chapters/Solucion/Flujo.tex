{\large{
    \textbf{1. Inicialización del Sistema:}
    \begin{itemize}
        \item \textbf{Entrada:} El programa recibe dos parámetros principales:
        \begin{itemize}
            \item $n$: Número de nodos en la red.
            \item $f$: Número de nodos bizantinos.
        \end{itemize}
        \item \textbf{Configuración de la Red:}
        \begin{itemize}
            \item \textit{Modelo Watts y Strogatz:} Se configura la topología de la red con base en este modelo, asegurando que el coeficiente de agrupamiento sea mayor a 0.4 antes de comenzar el proceso. Este modelo garantiza que los nodos estén interconectados de manera eficiente para propagar la información.
            \item \textbf{Creación de Nodos:} Se crean $n$ nodos, de los cuales $f$ son bizantinos, generando un total de $n - f$ nodos honestos, asegurando la desigualdad $n > 3f$ para mantener la integridad de la red.
        \end{itemize}
    \end{itemize}

    \vspace{0.5cm}

    \textbf{2. Creación de Procesos y Asignación de Roles:}
    \begin{itemize}
        \item \textbf{Spawning de Procesos:} Los nodos se representan como procesos concurrentes en Elixir, cada uno responsable de gestionar la lógica de su respectivo nodo en la blockchain. 
        
        Vamos a crear nodos con diferentes roles, como se muestra a continuación:
        \item \textbf{Asignación de Roles:}
        \begin{itemize}
            \item \textbf{Réplica:} Nodo que participa en el consenso de la red. Son todos los nodos excepto el líder; si quiere proponer un nodo lo manda al lider para que lo gestione.
            \item \textbf{Líder (o primary):} Nodo que coordina el consenso de la red. Este rol se deberia asignar dinámicamente en cada ronda usando un criterio determinista. Pero para simplificar, inicialmente se elige un nodo honesto arbitrariamente.
            \item \textbf{Bizantino:} Nodo que puede enviar mensajes maliciosos a la red. Este nodo también actúa como réplica, pero su comportamiento es defectuoso por diseño.
        \end{itemize}

        Los estados de los nodos se gestionan de manera local en cada proceso. Cada nodo tendrá un estado inicial que incluye:
        \begin{itemize}
            \item \textbf{ID único:} Identificador del nodo el que le da elixir vamos a usar para no confundirmelo con el PID.
            \item \textbf{Rol:} Líder, réplica o bizantino.
            \item \textbf{Blockchain local:} Registro de bloques confirmados.
            \item \textbf{Mensajes recibidos:} Historial temporal de mensajes relacionados con la ronda actual.
            \item \textbf{Lider: } El ID del lider actual.
        \end{itemize}
    \end{itemize}

    \vspace{0.5cm}

    \textbf{3. Ejecución del Consenso:}
    \begin{itemize}
        \item Los nodos y el líder colaboran para ejecutar el consenso pBFT según lo descrito en la \textbf{Sección 2.2: Consenso}.
        \item El proceso incluye las fases de \textit{pre-prepare}, \textit{prepare} y \textit{commit}, asegurando que todos los nodos honestos lleguen a un acuerdo sobre los bloques.
        \item Los nodos bizantinos intentarán interrumpir el consenso, enviando mensajes inconsistentes o maliciosos.
    \end{itemize}

    \vspace{0.5cm}

    \textbf{Resumen Visual del Flujo:}
    \begin{enumerate}
        \item \textbf{Inicialización:} Parámetros ($n$, $f$) → Topología de Red (Modelo Watts y Strogatz) → Creación de Nodos (honestos y bizantinos).
        \item \textbf{Asignación de Roles:} Líder creado, resto de nodos como réplicas (incluyendo bizantinos).
        \item \textbf{Consenso:} Se ejecuta pBFT (\textbf{ver Sección 2.2}) para alcanzar consenso sobre nuevos bloques.
        \item \textbf{Validación:} Cada nodo confirma el bloque acordado y lo agrega a su blockchain local.
    \end{enumerate}
}}

\vspace{0.5cm}