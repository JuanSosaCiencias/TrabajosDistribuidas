\large{
Para el consenso, el equipo decidió utilizar el algoritmo ya creado, \textbf{pBFT}; para la información de esta sección se utilizaron las referencias: \cite{geeksforgeeks_pbft} \cite{castro_liskov_1999}. 

La primera es más accesible y proporciona las bases del algoritmo, mientras que la segunda es más técnica, siendo el paper original. Este segundo recurso es útil para profundizar en el tema. 

Antes de explicar el consenso, los problemas que el algoritmo busca resolver son:
\begin{itemize}
    \item \textbf{Nodos Bizantinos:} Habrá nodos maliciosos que envíen mensajes incorrectos a la red. Nuestro sistema debe tolerarlos y alcanzar un consenso a pesar de su presencia.
    \item \textbf{Errores en los mensajes:} En una red real, los mensajes pueden perderse, retrasarse o llegar desordenados; asumimos que siempre llegan eventualmente. El sistema debe tolerar estos problemas y alcanzar el consenso.
    \item \textbf{Consistencia:} Todos los nodos honestos deben consensuar el orden de los bloques y validar su legitimidad.
    \item \textbf{Validez:} El consenso alcanzado no debe incluir bloques corruptos generados por nodos maliciosos.
\end{itemize}

}

\section*{El Algoritmo pBFT}

El algoritmo \textbf{pBFT} sigue tres etapas principales para llegar al consenso:

\begin{enumerate}
    \item \textbf{Preparación Inicial (Pre-Prepare):} 
    Un nodo propone un mensaje para ser aceptado por la red. Este mensaje, llamado \textit{preprepare}, contiene un identificador único (hash o timestamp) y el bloque propuesto.

    \item \textbf{Preparación (Prepare):} 
    Los nodos que reciben un mensaje \textit{preprepare} validan el bloque. Si es válido, envían un mensaje \textit{prepare} a sus vecinos. Cada nodo acumula mensajes \textit{prepare}. Si recibe al menos \(2f + 1\) mensajes válidos (incluido el suyo), pasa a la siguiente etapa.

    \item \textbf{Compromiso (Commit):} 
    En esta fase, el nodo envía un mensaje \textit{commit} a todos sus vecinos. Si un nodo acumula \(2f + 1\) mensajes \textit{commit} válidos, acepta el bloque y lo agrega a su \texttt{blockchain} local.
\end{enumerate}

Aunque el algoritmo tiene una complejidad de comunicación \(O(n^2)\), consideramos que esto es manejable para redes pequeñas o medianas.
